import { NextRequest, NextResponse } from 'next/server'
import { supabase } from '@/lib/supabase'

export async function POST(request: NextRequest) {
  try {
    const { name, description, userEmail, userName } = await request.json()

    if (!name) {
      return NextResponse.json({ error: 'Group name is required' }, { status: 400 })
    }

    if (!userEmail || !userName) {
      return NextResponse.json({ error: 'User email and name are required' }, { status: 400 })
    }

    // Create group (group_code will be auto-generated by trigger)
    const { data: group, error } = await supabase
      .from('groups')
      .insert({
        name,
        description,
      })
      .select()
      .single()

    if (error) {
      console.error('Error creating group:', error)
      return NextResponse.json({ error: 'Failed to create group' }, { status: 500 })
    }

    // Add creator as admin member
    const { error: memberError } = await supabase
      .from('group_members')
      .insert({
        group_id: group.id,
        user_email: userEmail,
        user_name: userName,
        role: 'admin',
      })

    if (memberError) {
      console.error('Error adding creator as member:', memberError)
      // Don't fail the request, just log the error
    }

    return NextResponse.json({ group })
  } catch (error) {
    console.error('Error in POST /api/groups:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const groupCode = searchParams.get('code')
    const userEmail = searchParams.get('userEmail')
    const groupId = searchParams.get('groupId')

    // Get single group by ID
    if (groupId) {
      const { data: group, error } = await supabase
        .from('groups')
        .select(`
          *,
          group_members (
            id,
            user_email,
            user_name,
            role,
            joined_at
          )
        `)
        .eq('id', groupId)
        .single()

      if (error) {
        console.error('Error fetching group by ID:', error)
        return NextResponse.json({ error: 'Group not found' }, { status: 404 })
      }

      // Transform members data to match expected format
      const transformedGroup = {
        ...group,
        members: group.group_members?.map((member: any) => ({
          id: member.id,
          email: member.user_email,
          name: member.user_name,
          role: member.role
        })) || []
      }

      return NextResponse.json({ group: transformedGroup })
    }

    // Get groups by user email
    if (userEmail) {
      const { data: groups, error } = await supabase
        .from('group_members')
        .select(`
          groups (
            id,
            name,
            description,
            group_code,
            created_at,
            updated_at,
            archived
          )
        `)
        .eq('user_email', userEmail)
        // Show both active and archived groups


      if (error) {
        console.error('Error fetching user groups:', error)
        return NextResponse.json({ error: 'Failed to fetch groups' }, { status: 500 })
      }

      // Transform the data and add expense totals and member counts
      const userGroups = groups?.map(item => item.groups).filter(Boolean) || []
      
      // Fetch additional data for each group
      const groupsWithStats = await Promise.all(
        userGroups.map(async (group: any) => {
          // Get member count
          const { count: memberCount } = await supabase
            .from('group_members')
            .select('*', { count: 'exact', head: true })
            .eq('group_id', group.id)

          // Get total expenses
          const { data: expenses } = await supabase
            .from('expenses')
            .select('amount')
            .eq('group_id', group.id)

          const totalExpenses = expenses?.reduce((sum, expense) => sum + expense.amount, 0) || 0

          return {
            ...group,
            memberCount: memberCount || 0,
            totalExpenses
          }
        })
      )

      return NextResponse.json({ groups: groupsWithStats })
    }

    // Get group by code (existing functionality)
    if (!groupCode) {
      return NextResponse.json({ error: 'Group code, userEmail, or groupId is required' }, { status: 400 })
    }

    const { data: group, error } = await supabase
      .from('groups')
      .select('*')
      .eq('group_code', groupCode)
      .single()

    if (error) {
      console.error('Error fetching group:', error)
      return NextResponse.json({ error: 'Group not found' }, { status: 404 })
    }

    return NextResponse.json({ group })
  } catch (error) {
    console.error('Error in GET /api/groups:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

export async function PUT(request: NextRequest) {
  try {
    const { groupId, name, description, userEmail, userName } = await request.json()

    if (!groupId || !name || !userEmail || !userName) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 })
    }

    // Get current group for audit log
    const { data: currentGroup } = await supabase
      .from('groups')
      .select('*')
      .eq('id', groupId)
      .single()

    if (!currentGroup) {
      return NextResponse.json({ error: 'Group not found' }, { status: 404 })
    }

    // Update group
    const { data: updatedGroup, error: updateError } = await supabase
      .from('groups')
      .update({
        name,
        description,
        updated_at: new Date().toISOString(),
      })
      .eq('id', groupId)
      .select()
      .single()

    if (updateError) {
      console.error('Error updating group:', updateError)
      return NextResponse.json({ error: 'Failed to update group' }, { status: 500 })
    }

    // Create audit log
    await supabase
      .from('audit_logs')
      .insert({
        entity_type: 'group',
        entity_id: groupId,
        action: 'UPDATE',
        changes: {
          before: {
            name: currentGroup.name,
            description: currentGroup.description,
          },
          after: {
            name,
            description,
          },
        },
        user_email: userEmail,
        user_name: userName,
      })

    return NextResponse.json({ group: updatedGroup })
  } catch (error) {
    console.error('Error in PUT /api/groups:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const groupId = searchParams.get('groupId')
    const { userEmail, userName } = await request.json()

    if (!groupId || !userEmail || !userName) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 })
    }

    // Check if user is admin of the group
    const { data: membership } = await supabase
      .from('group_members')
      .select('role')
      .eq('group_id', groupId)
      .eq('user_email', userEmail)
      .single()

    if (!membership || membership.role !== 'admin') {
      return NextResponse.json({ error: 'Only group admins can delete groups' }, { status: 403 })
    }

    // Get current group for audit log
    const { data: currentGroup } = await supabase
      .from('groups')
      .select('*')
      .eq('id', groupId)
      .single()


    if (!currentGroup) {
      return NextResponse.json({ error: 'Group not found' }, { status: 404 })
    }

    // Delete group (cascades to members, expenses, etc. due to foreign keys)
    const { data: deleteResult, error: deleteError } = await supabase
      .from('groups')
      .delete()
      .eq('id', groupId)
      .select()


    if (deleteError) {
      console.error('Error deleting group:', deleteError)
      return NextResponse.json({ error: 'Failed to delete group' }, { status: 500 })
    }

    // Create audit log
    await supabase
      .from('audit_logs')
      .insert({
        entity_type: 'group',
        entity_id: groupId,
        action: 'DELETE',
        changes: {
          deleted_group: {
            name: currentGroup.name,
            description: currentGroup.description,
            group_code: currentGroup.group_code,
          },
        },
        user_email: userEmail,
        user_name: userName,
      })

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Error in DELETE /api/groups:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

export async function PATCH(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const groupId = searchParams.get('groupId')
    const { archived, userEmail, userName } = await request.json()

    if (!groupId || !userEmail || !userName) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 })
    }

    // Check if user is admin of the group
    const { data: membership } = await supabase
      .from('group_members')
      .select('role')
      .eq('group_id', groupId)
      .eq('user_email', userEmail)
      .single()

    if (!membership || membership.role !== 'admin') {
      return NextResponse.json({ error: 'Only group admins can archive groups' }, { status: 403 })
    }

    // Get current group for audit log
    const { data: currentGroup } = await supabase
      .from('groups')
      .select('*')
      .eq('id', groupId)
      .single()

    if (!currentGroup) {
      return NextResponse.json({ error: 'Group not found' }, { status: 404 })
    }

    // Update group
    const { data: updatedGroup, error: updateError } = await supabase
      .from('groups')
      .update({
        archived: archived,
        updated_at: new Date().toISOString(),
      })
      .eq('id', groupId)
      .select()
      .single()

    if (updateError) {
      console.error('Error updating group:', updateError)
      return NextResponse.json({ error: 'Failed to update group' }, { status: 500 })
    }

    // Create audit log
    await supabase
      .from('audit_logs')
      .insert({
        entity_type: 'group',
        entity_id: groupId,
        action: archived ? 'ARCHIVE' : 'UNARCHIVE',
        changes: {
          before: {
            archived: currentGroup.archived,
          },
          after: {
            archived: archived,
          },
        },
        user_email: userEmail,
        user_name: userName,
      })

    return NextResponse.json({ group: updatedGroup })
  } catch (error) {
    console.error('Error in PATCH /api/groups:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
